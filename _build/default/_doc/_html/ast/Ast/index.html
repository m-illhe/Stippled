<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (ast.Ast)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ast</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>Ast</span></code></h1><p>Module that represent programs in the Stippled language. A program is composed of a list of argument, followed by a statement that is the body of the program. Statements contain expressions. Arguments, statements and expressions contain annotations (their position and types).</p><p>This modules contains also a set of printer functions.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-type_expr" class="anchored"><a href="#type-type_expr" class="anchor"></a><code><span><span class="keyword">type</span> type_expr</span><span> = </span></code><table><tr id="type-type_expr.Type_int" class="anchored"><td class="def variant constructor"><a href="#type-type_expr.Type_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_int</span></span></code></td></tr><tr id="type-type_expr.Type_float" class="anchored"><td class="def variant constructor"><a href="#type-type_expr.Type_float" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_float</span></span></code></td></tr><tr id="type-type_expr.Type_bool" class="anchored"><td class="def variant constructor"><a href="#type-type_expr.Type_bool" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_bool</span></span></code></td></tr><tr id="type-type_expr.Type_pos" class="anchored"><td class="def variant constructor"><a href="#type-type_expr.Type_pos" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_pos</span></span></code></td></tr><tr id="type-type_expr.Type_color" class="anchored"><td class="def variant constructor"><a href="#type-type_expr.Type_color" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_color</span></span></code></td></tr><tr id="type-type_expr.Type_point" class="anchored"><td class="def variant constructor"><a href="#type-type_expr.Type_point" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_point</span></span></code></td></tr><tr id="type-type_expr.Type_list" class="anchored"><td class="def variant constructor"><a href="#type-type_expr.Type_list" class="anchor"></a><code><span>| </span><span><span class="constructor">Type_list</span> <span class="keyword">of</span> <a href="#type-type_expr">type_expr</a></span></code></td></tr></table></div><div class="spec-doc"><p>Types of the language</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Annotation" class="anchored"><a href="#module-Annotation" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Annotation/index.html">Annotation</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module representing annotations of elements of the program. It contains the <a href="../../util/Util/Position/index.html#type-t"><code>Util.Position.t</code></a> of the parsed text that represent the element, and its <a href="#type-type_expr"><code>type_expr</code></a>. The type is only useful for expressions.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-binary_operator" class="anchored"><a href="#type-binary_operator" class="anchor"></a><code><span><span class="keyword">type</span> binary_operator</span><span> = </span></code><table><tr id="type-binary_operator.Add" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Addition over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a>, <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a>, <a href="#type-type_expr.Type_color"><code>Type_color</code></a> and <a href="#type-type_expr.Type_point"><code>Type_point</code></a>, and concatenation over <a href="#type-type_expr.Type_list"><code>Type_list</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Sub" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Substraction over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a>, <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a>, <a href="#type-type_expr.Type_color"><code>Type_color</code></a> and <a href="#type-type_expr.Type_point"><code>Type_point</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Mul" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Multiplication over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a>, <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a>, <a href="#type-type_expr.Type_color"><code>Type_color</code></a> and <a href="#type-type_expr.Type_point"><code>Type_point</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Div" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Division over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a>, <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a>, <a href="#type-type_expr.Type_color"><code>Type_color</code></a> and <a href="#type-type_expr.Type_point"><code>Type_point</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Mod" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Modulus over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a>, <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a>, <a href="#type-type_expr.Type_color"><code>Type_color</code></a> and <a href="#type-type_expr.Type_point"><code>Type_point</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.And" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Boolean and</p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Or" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Boolean or</p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Eq" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Equality (polymorphic)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Ne" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Ne" class="anchor"></a><code><span>| </span><span><span class="constructor">Ne</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Inequality (polymorphic)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Lt" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&lt; (over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a> and <a href="#type-type_expr.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Gt" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&gt; (over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a> and <a href="#type-type_expr.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Le" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Le" class="anchor"></a><code><span>| </span><span><span class="constructor">Le</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&lt;= (over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a> and <a href="#type-type_expr.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binary_operator.Ge" class="anchored"><td class="def variant constructor"><a href="#type-binary_operator.Ge" class="anchor"></a><code><span>| </span><span><span class="constructor">Ge</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&gt;= (over <a href="#type-type_expr.Type_int"><code>Type_int</code></a>, <a href="#type-type_expr.Type_float"><code>Type_float</code></a> and <a href="#type-type_expr.Type_bool"><code>Type_bool</code></a>)</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Binary operators over <a href="#type-expression"><code>expression</code></a>. Operations over <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a>, <a href="#type-type_expr.Type_color"><code>Type_color</code></a> and <a href="#type-type_expr.Type_point"><code>Type_point</code></a> are applied member by member (i.e., (a,b) + (c,d) * (a+c,b+d)).</p></div></div><div class="odoc-spec"><div class="spec type" id="type-unary_operator" class="anchored"><a href="#type-unary_operator" class="anchor"></a><code><span><span class="keyword">type</span> unary_operator</span><span> = </span></code><table><tr id="type-unary_operator.USub" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.USub" class="anchor"></a><code><span>| </span><span><span class="constructor">USub</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unary minus (over <a href="#type-type_expr.Type_int"><code>Type_int</code></a> and <a href="#type-type_expr.Type_float"><code>Type_float</code></a>)</p><span class="comment-delim">*)</span></td></tr><tr id="type-unary_operator.Not" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Boolean negation</p><span class="comment-delim">*)</span></td></tr><tr id="type-unary_operator.Head" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.Head" class="anchor"></a><code><span>| </span><span><span class="constructor">Head</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Head of a list</p><span class="comment-delim">*)</span></td></tr><tr id="type-unary_operator.Tail" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.Tail" class="anchor"></a><code><span>| </span><span><span class="constructor">Tail</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Tail of a list</p><span class="comment-delim">*)</span></td></tr><tr id="type-unary_operator.Floor" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.Floor" class="anchor"></a><code><span>| </span><span><span class="constructor">Floor</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The biggest <a href="#type-type_expr.Type_int"><code>Type_int</code></a> smaller than the <a href="#type-type_expr.Type_float"><code>Type_float</code></a> given</p><span class="comment-delim">*)</span></td></tr><tr id="type-unary_operator.Float_of_int" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.Float_of_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Float_of_int</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The <a href="#type-type_expr.Type_float"><code>Type_float</code></a> corresponding to the <a href="#type-type_expr.Type_int"><code>Type_int</code></a> given</p><span class="comment-delim">*)</span></td></tr><tr id="type-unary_operator.Cos" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.Cos" class="anchor"></a><code><span>| </span><span><span class="constructor">Cos</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Cosinus function over <a href="#type-type_expr.Type_float"><code>Type_float</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-unary_operator.Sin" class="anchored"><td class="def variant constructor"><a href="#type-unary_operator.Sin" class="anchor"></a><code><span>| </span><span><span class="constructor">Sin</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Sinus function over <a href="#type-type_expr.Type_float"><code>Type_float</code></a></p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Unary operator over the language</p></div></div><div class="odoc-spec"><div class="spec type" id="type-field_accessor" class="anchored"><a href="#type-field_accessor" class="anchor"></a><code><span><span class="keyword">type</span> field_accessor</span><span> = </span></code><table><tr id="type-field_accessor.Color_accessor" class="anchored"><td class="def variant constructor"><a href="#type-field_accessor.Color_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Color_accessor</span></span></code></td></tr><tr id="type-field_accessor.Position_accessor" class="anchored"><td class="def variant constructor"><a href="#type-field_accessor.Position_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Position_accessor</span></span></code></td></tr><tr id="type-field_accessor.X_accessor" class="anchored"><td class="def variant constructor"><a href="#type-field_accessor.X_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">X_accessor</span></span></code></td></tr><tr id="type-field_accessor.Y_accessor" class="anchored"><td class="def variant constructor"><a href="#type-field_accessor.Y_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Y_accessor</span></span></code></td></tr><tr id="type-field_accessor.Blue_accessor" class="anchored"><td class="def variant constructor"><a href="#type-field_accessor.Blue_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Blue_accessor</span></span></code></td></tr><tr id="type-field_accessor.Red_accessor" class="anchored"><td class="def variant constructor"><a href="#type-field_accessor.Red_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Red_accessor</span></span></code></td></tr><tr id="type-field_accessor.Green_accessor" class="anchored"><td class="def variant constructor"><a href="#type-field_accessor.Green_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Green_accessor</span></span></code></td></tr></table></div><div class="spec-doc"><p>Accessors to field of <a href="#type-type_expr.Type_point"><code>Type_point</code></a>, <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a> and <a href="#type-type_expr.Type_color"><code>Type_color</code></a></p></div></div><div class="odoc-spec"><div class="spec type" id="type-expression" class="anchored"><a href="#type-expression" class="anchor"></a><code><span><span class="keyword">type</span> expression</span><span> = </span></code><table><tr id="type-expression.Constant_i" class="anchored"><td class="def variant constructor"><a href="#type-expression.Constant_i" class="anchor"></a><code><span>| </span><span><span class="constructor">Constant_i</span> <span class="keyword">of</span> int * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.Constant_f" class="anchored"><td class="def variant constructor"><a href="#type-expression.Constant_f" class="anchor"></a><code><span>| </span><span><span class="constructor">Constant_f</span> <span class="keyword">of</span> float * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.Constant_b" class="anchored"><td class="def variant constructor"><a href="#type-expression.Constant_b" class="anchor"></a><code><span>| </span><span><span class="constructor">Constant_b</span> <span class="keyword">of</span> bool * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.Pos" class="anchored"><td class="def variant constructor"><a href="#type-expression.Pos" class="anchor"></a><code><span>| </span><span><span class="constructor">Pos</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Creates a <a href="#type-type_expr.Type_pos"><code>Type_pos</code></a> from the two expressions in argument.</p><span class="comment-delim">*)</span></td></tr><tr id="type-expression.Color" class="anchored"><td class="def variant constructor"><a href="#type-expression.Color" class="anchor"></a><code><span>| </span><span><span class="constructor">Color</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Creates a <a href="#type-type_expr.Type_color"><code>Type_color</code></a> from the three expressions in argument.</p><span class="comment-delim">*)</span></td></tr><tr id="type-expression.Point" class="anchored"><td class="def variant constructor"><a href="#type-expression.Point" class="anchor"></a><code><span>| </span><span><span class="constructor">Point</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Creates a <a href="#type-type_expr.Type_point"><code>Type_point</code></a> from the two expressions in argument.</p><span class="comment-delim">*)</span></td></tr><tr id="type-expression.Variable" class="anchored"><td class="def variant constructor"><a href="#type-expression.Variable" class="anchor"></a><code><span>| </span><span><span class="constructor">Variable</span> <span class="keyword">of</span> string * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.Binary_operator" class="anchored"><td class="def variant constructor"><a href="#type-expression.Binary_operator" class="anchor"></a><code><span>| </span><span><span class="constructor">Binary_operator</span> <span class="keyword">of</span> <a href="#type-binary_operator">binary_operator</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.Unary_operator" class="anchored"><td class="def variant constructor"><a href="#type-expression.Unary_operator" class="anchor"></a><code><span>| </span><span><span class="constructor">Unary_operator</span> <span class="keyword">of</span> <a href="#type-unary_operator">unary_operator</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.Field_accessor" class="anchored"><td class="def variant constructor"><a href="#type-expression.Field_accessor" class="anchor"></a><code><span>| </span><span><span class="constructor">Field_accessor</span> <span class="keyword">of</span> <a href="#type-field_accessor">field_accessor</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.List" class="anchored"><td class="def variant constructor"><a href="#type-expression.List" class="anchor"></a><code><span>| </span><span><span class="constructor">List</span> <span class="keyword">of</span> <span><a href="#type-expression">expression</a> list</span> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-expression.Cons" class="anchored"><td class="def variant constructor"><a href="#type-expression.Cons" class="anchor"></a><code><span>| </span><span><span class="constructor">Cons</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr></table></div><div class="spec-doc"><p>The expressions of the language. Only non-obvious cases are commented below. Every expression contains an <a href="Annotation/index.html#type-t"><code>Annotation.t</code></a></p></div></div><div class="odoc-spec"><div class="spec type" id="type-statement" class="anchored"><a href="#type-statement" class="anchor"></a><code><span><span class="keyword">type</span> statement</span><span> = </span></code><table><tr id="type-statement.Assignment" class="anchored"><td class="def variant constructor"><a href="#type-statement.Assignment" class="anchor"></a><code><span>| </span><span><span class="constructor">Assignment</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-statement.Variable_declaration" class="anchored"><td class="def variant constructor"><a href="#type-statement.Variable_declaration" class="anchor"></a><code><span>| </span><span><span class="constructor">Variable_declaration</span> <span class="keyword">of</span> string * <a href="#type-type_expr">type_expr</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-statement.Block" class="anchored"><td class="def variant constructor"><a href="#type-statement.Block" class="anchor"></a><code><span>| </span><span><span class="constructor">Block</span> <span class="keyword">of</span> <span><a href="#type-statement">statement</a> list</span> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Block of consecutive statements. Declarations in this block are local to it</p><span class="comment-delim">*)</span></td></tr><tr id="type-statement.IfThenElse" class="anchored"><td class="def variant constructor"><a href="#type-statement.IfThenElse" class="anchor"></a><code><span>| </span><span><span class="constructor">IfThenElse</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="#type-statement">statement</a> * <a href="#type-statement">statement</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr><tr id="type-statement.For" class="anchored"><td class="def variant constructor"><a href="#type-statement.For" class="anchor"></a><code><span>| </span><span><span class="constructor">For</span> <span class="keyword">of</span> string * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-statement">statement</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For loop. <code>For(str,init,target,step,body,annot)</code> starts by initialising variable <code>str</code> (which must be declared) to the value of <code>init</code>, and executes <code>body</code> and then increments <code>str</code> by the value of <code>step</code> as long as the value in <code>str</code> is smaller than that of <code>target</code>. <code>target</code> is reevaluated at each step. Can be used for <a href="#type-type_expr.Type_int"><code>Type_int</code></a> or <a href="#type-type_expr.Type_float"><code>Type_float</code></a> variables</p><span class="comment-delim">*)</span></td></tr><tr id="type-statement.Foreach" class="anchored"><td class="def variant constructor"><a href="#type-statement.Foreach" class="anchor"></a><code><span>| </span><span><span class="constructor">Foreach</span> <span class="keyword">of</span> string * <a href="#type-expression">expression</a> * <a href="#type-statement">statement</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Foreach(str,list,body,annotation)</code> requires that <code>list</code> is a <a href="#type-type_expr.Type_list"><code>Type_list</code></a>. It applies <code>body</code> to every element of the list (from left to right). In <code>body</code>, the current element of the loop is stored in variable <code>str</code> (which is not required to be declared)</p><span class="comment-delim">*)</span></td></tr><tr id="type-statement.Draw" class="anchored"><td class="def variant constructor"><a href="#type-statement.Draw" class="anchor"></a><code><span>| </span><span><span class="constructor">Draw</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Draw(point,annot)</code> draws <code>point</code> on the window of the program. <code>point</code> must be of type <a href="#type-type_expr.Type_point"><code>Type_point</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-statement.Nop" class="anchored"><td class="def variant constructor"><a href="#type-statement.Nop" class="anchor"></a><code><span>| </span><span><span class="constructor">Nop</span></span></code></td></tr><tr id="type-statement.Print" class="anchored"><td class="def variant constructor"><a href="#type-statement.Print" class="anchor"></a><code><span>| </span><span><span class="constructor">Print</span> <span class="keyword">of</span> <a href="#type-expression">expression</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Print(expr,annot)</code> displays the value of <code>expr</code> in the terminal (for debugging purposes)</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>The statements of the language. Only non-obvious cases are commented below. Every statement contains an <a href="Annotation/index.html#type-t"><code>Annotation.t</code></a>, except <a href="#type-statement.Nop"><code>Nop</code></a></p></div></div><div class="odoc-spec"><div class="spec type" id="type-argument" class="anchored"><a href="#type-argument" class="anchor"></a><code><span><span class="keyword">type</span> argument</span><span> = </span></code><table><tr id="type-argument.Argument" class="anchored"><td class="def variant constructor"><a href="#type-argument.Argument" class="anchor"></a><code><span>| </span><span><span class="constructor">Argument</span> <span class="keyword">of</span> string * <a href="#type-type_expr">type_expr</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></td></tr></table></div><div class="spec-doc"><p>Argument of the program</p></div></div><div class="odoc-spec"><div class="spec type" id="type-program" class="anchored"><a href="#type-program" class="anchor"></a><code><span><span class="keyword">type</span> program</span><span> = </span></code><table><tr id="type-program.Program" class="anchored"><td class="def variant constructor"><a href="#type-program.Program" class="anchor"></a><code><span>| </span><span><span class="constructor">Program</span> <span class="keyword">of</span> <span><a href="#type-argument">argument</a> list</span> * <a href="#type-statement">statement</a></span></code></td></tr></table></div><div class="spec-doc"><p>Type that represent a Stippled program. It contains a (possibly empty) list of declaration of arguments that will be read on the arguments of the interpreter, and a statement that is the body of the program. Every type can be read of argument, except of list of non-base type (i.e. list of int can be read, but not list of list of int).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_type_expr" class="anchored"><a href="#val-string_of_type_expr" class="anchor"></a><code><span><span class="keyword">val</span> string_of_type_expr : <span><a href="#type-type_expr">type_expr</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_binary_operator" class="anchored"><a href="#val-string_of_binary_operator" class="anchor"></a><code><span><span class="keyword">val</span> string_of_binary_operator : <span><a href="#type-binary_operator">binary_operator</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_unary_operator" class="anchored"><a href="#val-string_of_unary_operator" class="anchor"></a><code><span><span class="keyword">val</span> string_of_unary_operator : <span><a href="#type-unary_operator">unary_operator</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_field_accessor" class="anchored"><a href="#val-string_of_field_accessor" class="anchor"></a><code><span><span class="keyword">val</span> string_of_field_accessor : <span><a href="#type-field_accessor">field_accessor</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_expression" class="anchored"><a href="#val-string_of_expression" class="anchor"></a><code><span><span class="keyword">val</span> string_of_expression : <span><a href="#type-expression">expression</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_pos" class="anchored"><a href="#val-string_of_pos" class="anchor"></a><code><span><span class="keyword">val</span> string_of_pos : <span><span>(<a href="#type-expression">expression</a> * <a href="#type-expression">expression</a>)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_color" class="anchored"><a href="#val-string_of_color" class="anchor"></a><code><span><span class="keyword">val</span> string_of_color : <span><span>(<a href="#type-expression">expression</a> * <a href="#type-expression">expression</a> * <a href="#type-expression">expression</a>)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_list" class="anchored"><a href="#val-string_of_list" class="anchor"></a><code><span><span class="keyword">val</span> string_of_list : <span><span><a href="#type-expression">expression</a> list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_statement" class="anchored"><a href="#val-pp_statement" class="anchor"></a><code><span><span class="keyword">val</span> pp_statement : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-statement">statement</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_argument" class="anchored"><a href="#val-pp_argument" class="anchor"></a><code><span><span class="keyword">val</span> pp_argument : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-argument">argument</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_program" class="anchored"><a href="#val-pp_program" class="anchor"></a><code><span><span class="keyword">val</span> pp_program : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-program">program</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>